# -*- coding: utf-8 -*-
"""ROS_simulator.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WzB3BIiUv5ISkYfx880IpzLbqv9JqXYF
"""

import threading
import time
import random
import matplotlib.pyplot as plt
import numpy as np

class BayesianNetwork:
    def __init__(self, num_networks):
        self.num_networks = num_networks
        self.networks = [self.create_network() for _ in range(num_networks)]

    def create_network(self):
        network = {'Knowledge': None, 'Intent': None, 'Observation': None, 'Trust': None}
        probabilities = {'Knowledge': None, 'Intent': None, 'Observation': None, 'Trust': None}
        # Generate random probabilities for each node
        for node in network:
            probabilities[node] = {value: random.random() for value in [0, 1]}
            probabilities[node] = {k: v / sum(probabilities[node].values()) for k, v in probabilities[node].items()}
        probabilities['Trust'] = {(i, j, k): random.random() for i in [0, 1] for j in [0, 1] for k in [0, 1]}
        probabilities['Trust'] = {k: v / sum(probabilities['Trust'].values()) for k, v in probabilities['Trust'].items()}
        return network, probabilities

    def query(self, evidence, network_index=0):
        network, probabilities = self.networks[network_index]
        knowledge_prob = probabilities['Knowledge'][evidence['Knowledge']]
        intent_prob = probabilities['Intent'][evidence['Intent']]
        observation_prob = probabilities['Observation'][evidence['Observation']]
        trust_prob_key = (evidence['Knowledge'], evidence['Intent'], evidence['Observation'])
        trust_prob = probabilities['Trust'].get(trust_prob_key, 0)  # Get trust probability or default to 0 if key not found
        posterior_prob = trust_prob * knowledge_prob * intent_prob * observation_prob
        return posterior_prob

class ROSPublisher:
    def __init__(self, topic, choices, publish_interval):
        self.topic = topic
        self.choices = choices
        self.publish_interval = publish_interval
        self.publisher_thread = threading.Thread(target=self.publish)
        self.running = False

    def start(self):
        self.running = True
        self.publisher_thread.start()

    def stop(self):
        self.running = False

    def publish(self):
        while self.running:
            data = random.choice(self.choices)
            print(f"Publishing {self.topic}: {data}")
            time.sleep(random.uniform(0.5, 1.5))

class ROSNode:
    def __init__(self, name, publisher):
        self.name = name
        self.publisher = publisher

class ROSObserver:
    def __init__(self):
        self.observers = []

    def add_observer(self, node):
        self.observers.append(node)

    def remove_observer(self, node):
        self.observers.remove(node)

    def notify_observers(self, data):
        for observer in self.observers:
            print(f"Notifying {observer.name} about {data}")
            observer.publisher.publish(data)

def plot_graph(x_data, y_data):
    plt.plot(x_data, y_data)
    plt.xlabel('Time')
    plt.ylabel('Posterior Probability of Trust')
    plt.title('Real-Time Posterior Probability of Trust')
    plt.show()

def collect_data(bn, num_samples, num_iterations):
    data = np.zeros((num_samples, num_iterations))
    for i in range(num_iterations):
        evidence = {'Knowledge': random.choice([0, 1]), 'Intent': random.choice([0, 1]), 'Observation': random.choice([0, 1])}
        for j in range(num_samples):
            posterior_prob = bn.query(evidence)
            data[j][i] = posterior_prob
    return data

def main():
    num_networks = 3
    bn = BayesianNetwork(num_networks)

    knowledge_publisher = ROSPublisher("Knowledge", [0, 1], 1)
    intent_publisher = ROSPublisher("Intent", [0, 1], 1)
    observation_publisher = ROSPublisher("Observation", [0, 1], 1)
    knowledge_publisher.start()
    intent_publisher.start()
    observation_publisher.start()

    knowledge_node = ROSNode("Knowledge Node", knowledge_publisher)
    intent_node = ROSNode("Intent Node", intent_publisher)
    observation_node = ROSNode("Observation Node", observation_publisher)

    observer = ROSObserver()
    observer.add_observer(knowledge_node)
    observer.add_observer(intent_node)
    observer.add_observer(observation_node)

    x_data = []
    y_data = []

    for _ in range(10):
        knowledge_data = random.choice([0, 1])
        intent_data = random.choice([0, 1])
        observation_data = random.choice([0, 1])
        evidence = {'Knowledge': knowledge_data, 'Intent': intent_data, 'Observation': observation_data}
        posterior_prob = bn.query(evidence)
        x_data.append(len(x_data) + 1)
        y_data.append(posterior_prob)
        print(f"Posterior probability of Trust: {posterior_prob}")
        time.sleep(random.uniform(0.5, 1.5))

    plot_graph(x_data, y_data)

    # Collect simulated data for analysis
    num_samples = 100
    num_iterations = 1000
    data = collect_data(bn, num_samples, num_iterations)
    # Perform statistical analysis on collected data
    mean_posterior_prob = np.mean(data, axis=0)
    std_dev_posterior_prob = np.std(data, axis=0)
    max_posterior_prob = np.max(data, axis=0)
    min_posterior_prob = np.min(data, axis=0)

    # Print statistical analysis
    print("Mean posterior probability of Trust:", mean_posterior_prob)
    print("Standard deviation of posterior probability of Trust:", std_dev_posterior_prob)
    print("Maximum posterior probability of Trust:", max_posterior_prob)
    print("Minimum posterior probability of Trust:", min_posterior_prob)

    # Plot statistical analysis
    plt.figure(figsize=(10, 6))
    plt.subplot(2, 2, 1)
    plt.bar(['Mean', 'Std Dev', 'Max', 'Min'], [mean_posterior_prob[-1], std_dev_posterior_prob[-1], max_posterior_prob[-1], min_posterior_prob[-1]])
    plt.title("Posterior Probability of Trust Analysis")
    plt.ylabel("Probability")
    plt.xlabel("Statistics")

    plt.subplot(2, 2, 2)
    plt.bar(['Mean', 'Std Dev', 'Max', 'Min'], [mean_posterior_prob[-2], std_dev_posterior_prob[-2], max_posterior_prob[-2], min_posterior_prob[-2]])
    plt.title("Posterior Probability of Intent Analysis")
    plt.ylabel("Probability")
    plt.xlabel("Statistics")

    plt.subplot(2, 2, 3)
    plt.bar(['Mean', 'Std Dev', 'Max', 'Min'], [mean_posterior_prob[-3], std_dev_posterior_prob[-3], max_posterior_prob[-3], min_posterior_prob[-3]])
    plt.title("Posterior Probability of Knowledge Analysis")
    plt.ylabel("Probability")
    plt.xlabel("Statistics")

    plt.subplot(2, 2, 4)
    plt.bar(['Mean', 'Std Dev', 'Max', 'Min'], [mean_posterior_prob[-4], std_dev_posterior_prob[-4], max_posterior_prob[-4], min_posterior_prob[-4]])
    plt.title("Posterior Probability of Observation Analysis")
    plt.ylabel("Probability")
    plt.xlabel("Statistics")

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    main()

